# ddd_study

## 値オブジェクト

以下を満たすオブジェクト。

- 不変である
- 交換不可である
- 等価性によって比較される

1 == 0 の比較の時、 1.value == 0.value みたいなことはしないよね。

プリミティブな型でも表現できるような概念が存在するとき、値オブジェクトにするかどうかは以下の基準で考えると良い（筆者意見）

- ルールがある
- その概念を単体で利用する

ドメインに合わせた値オブジェクトを用意することで、ドメインをソフトウェアで表せるようになる。

## エンティティ

値オブジェクトと対照的に、以下の条件を持つオブジェクト。

- 可変である
- 同じ属性であっても区別される
- 同一性により区別される

例えば、ユーザとか。IDで判別され、その属性情報の変更によって別物にならない。

可変なオブジェクトは基本的に厄介なので、可能な限り不変にしておくことは良い習慣。

ライフサイクルがある概念はエンティティとして扱うと良い。

## ドメインサービス

エンティティに持たせるには不自然なドメイン的な処理をまとめたもの。Service。
基本的にエンティティに関する処理はエンティティが持つべきだが、不自然な場合はServiceに切り出すと良い。
ただし、エンティティモデルの貧血症（無言のオブジェクトになってしまうこと）には注意。なるべくサービスには実装しない。

ドメインサービスの命名には、以下のようなパターンが考えられる。

- ドメインの概念
- ドメインの概念 + Service
- ドメインの概念 + DomainService

特定のドメインオブジェクトに密接に関わるなら、ModelnameServiceみたいな感じもいいし、
重複を調べることに重点をおいたサービスなら、CheckDuplicationServiceみたいな感じもいい。
DomainServiceと付ければ、一番可読性は高いが冗長でもある。チームの共通認識が取れていれば不要かも。

## リポジトリ

リポジトリは、オブジェクトを永続化（保存）、破棄することのみを目的としたもの。
オブジェクトの作成や更新は含まない（レポジトリではなくオブジェクトが担当すべき）。

レポジトリの関数の引数には、オブジェクトを渡すと良い。
属性の1つ1つを渡すようにすると、関数の数が多くなってしまう。

## アプリケーションサービス

ユースケース（アプリとしてやりたいこと、「誰」が「何」をしたい）を実現するためのサービス。

ドメインオブジェクトを公開すると、実装量は減るが、ドメインオブジェクトに対する予想外の処理が記述される可能性が出る。
そのため、ドメインオブジェクトのデータだけをClientに渡したい場合、DTO（Data Transfer Object）を介すると良い。
DTOからドメインオブジェクトへの依存が強くなることは問題ない。

コマンドオブジェクトを用意し、serviceの関数への入力パラメータの増減に対処するテクニックがある。

アプリケーションサービスにはドメインルールが流出しないようにする。

プログラムの凝集度は、基本的には高いほど良い（例外もあるが）。
凝集度の計算方法の一つに、LCOM（Lack of Cohension in Methods）というものがある。
端的にいうと、全てのインスタンス変数は、全てのメソッドで使われるべき。
もしそうなっていなければ、クラスを分割して、凝集度を高めるとbetterになることが多い。

サービスには状態を持たせるべきではない。基本的には回避しよう。

## 依存関係のコントロール

DIPの話。抽象に依存しよう。

### ServiceLocatorパターン

ServiceLocatorが、どのServiceを利用するかを制御するパターン。
これはアンチパターンと言われている。理由は以下。

- 依存関係が外部から見づらくなる。
  - 事前に設定が必要なことを、Serviceのクラスだけからは想定しづらい。
- テストの維持が難しくなる。
  - 呼び元のServiceの変更により、テストが破壊されたことに、テストを実行するまで気がつきづらい。

### IoC（Inversion of Control） Container（DI Container）パターン

DependencyをInjection（コンストラクタに突っ込む）するのが定番だが。
このパターンでは、Dependencyが変更されると、全ての関連箇所の変更が必要になる。
そこで役立つのがIoCパターン。

```csharp
// IoC Container
var serviceCollection = new ServiceCollection();
// 依存解決の設定を登録する
serviceCollection.AddTransient<IUserRepository, InMemoryUserRepository>();
serviceCollection.AddTransient<UserApplicationService>();

// インスタンスはIoC Container経由で取得する
var provider = serviceCollection.BuildServiceProvider();
var userApplicationService = provider.GetService<UserApplicationService>();

成瀬 允宣. ドメイン駆動設計入門 ボトムアップでわかる！ドメイン駆動設計の基本 (p.273). 株式会社翔泳社. Kindle 版. 
```

IoC Containerの設定は、ServiceLocatorと同様、スタートアップスクリプトなどで行う。

## ソフトウェアシステムを組み立てる

### シングルトンパターンの誤解

シングルトンパターンをStaticの代わりに使う例を見かけるが、これは誤解。
staticで済むならstaticにしましょう。
シングルトンの目的は、インスタンスを一つに限定しつつ、オブジェクトとして扱える点。

## ファクトリ

ドメインオブジェクトなどを生成することを担うClass。
生成のプロセスが複雑であったり、外部に依存するときに有効。
ファクトリを用意しても、ファクトリの存在が別の開発者に気づかれない（生成対象のClassの中身にはfactoryに関する記述はない）可能性があるため、packageにわかりやすく同居させたりするとGood。

DBにはたいてい自動採番機能があるが、これをアプリから利用するのはリスクがあるので、注意。
オブジェクト生成時にidが存在していないことや、エンティティのidがリポジトリからsetされることなど。

自動採番についてもリポジトリのClassが担うパターンもあり、可能ではある。
ただ、責任範囲が広がることや、registerと採番で違う技術基盤を利用していた時などに違和感がでる。

コンストラクタが複雑になる時は、ファクトリを活用しよう。
コンストラクタは単純であるべき。

## データの整合性を保つ

同時登録などで、重複チェックをすり抜けないように注意。
DBMSのユニーク制約なども多重チェックに含めよう。


C#ならTransactionScopeを活用したり、JavaならASPのTransactionalアノテーションを利用したり。

UnitOfWorkパターン。
C#のEntity FrameworkはUOWの実装パターン。

トランザクションが引き起こすロックは、可能な限り小さくしておくとGood。


## アプリケーションを1から組み立てる

## ドメインルールを守る「集約」

集約（Aggregate）とは、オブジェクトにその概念の操作が集約されていること。
デルメルの法則。

通知（Notification）オブジェクトを用いて、プライベートなメンバー変数を通知するようにすると、ゲッターによる呼び出しを回避できる。

原則、メンバー変数は公開しないが、識別子に関してはメリットが上回る場合がある。

集約はなるべく小さく、トランザクションはなるべく小さく。
複数の集約にまたがるトランザクションは控える。

## 様々な条件を表現する「仕様（Spec）」

オブジェクトの評価用のメソッドをまとめたClass。
名前の通り、仕様を表現し、アプリケーションサービスから利用する。

例えば、人気のコンテンツを推薦するロジックを考える。
人気のコンテンツの定義をSpecファイルにまとめ、その定義を利用して推薦するようにすれば、リポジトリに侵食されない。

仕様をリポジトリのフィルターとして利用する場合、パフォーマンスに注意。

CQSやCQRSなどの考え方のように、
コマンド（書き込み）においてはドメインオブジェクトを活用し、クエリ（読み取り）はある程度緩和するという考え方もある。

オブジェクトの評価はそれ単体で知識になりえます。仕様は評価の条件や手順をモデルにしたオブジェクトです。 
オブジェクトの評価をオブジェクト自身にさせることが常に正しいとは限りません。仕様のような外部のオブジェクトに評価させる手法の方が素直なコードになることも多いでしょう。

## アーキテクチャ

- レイヤードアーキテクチャ
- ヘキサゴナルアーキテクチャ
- クリーンアーキテクチャ

などが有名。

### レイヤードアーキテクチャ

レイヤードアーキテクチャは、DDD本で紹介されている。
4つのレイヤーが

### ヘキサゴナルアーキテクチャ

中心にドメインロジックがあり、周辺とadapterで接続する。

### クリーンアーキテクチャ

中心にドメインロジック（Entities）があり、その周りにusecase層、Adapter層、Presentation層があるイメージで、中心に向けて依存していくことを徹底する。

ヘキサゴナルアーキテクチャと同じようなコンセプトで、違いとしてはクリーンアーキテクチャの文脈では実装例が存在すること。

## ドメイン駆動設計の扉を開こう

ドメインエキスパートと対話し、ドメインモデル、コードを双方向に洗練していこう。
あなたがProduct OwnerやPdMなら、ドメインエキスパートとの会話の仲介役ではなく、開発者を直接会話させよう。

### ユビキタス言語

プロジェクト内のメンバー間で、使用する言葉が異なることは、問題を招く。
言葉を統一しよう。という考え方。

例えば。
そのドメインにおいて「ユーザ名を変更する」という表現が適切な場合、
コード上では、changeName()と実装すべき。updateName()では言葉が異なる。

### 境界づけられたコンテキスト

同じドメインの中で、コンテクストごとに言葉の意味や、言葉が異なることがある。
そういう場合は、コンテキスト別にClassを分割したりもできる。

この際、コンテキストマップを作成しておかないと、どのClassがつながっているかに気付きづらくなる。

## 付録：ファイル構成例

- Application
  - Users
    - Create
      - IUserCreateInputPort.java
      - UserCreateInputData.java
      - UserCreateInteractor.java
- Domain
  - Models
    - Users
      - User.java
      - UserId.java
      - UserName.java
  - Services
    - UserService.java
  - Shared
    - ISpecification.java
- Infra
  - InMemory
    - Users
      - InMemoryUserFactory.java
      - InMemoryUserRepository.java